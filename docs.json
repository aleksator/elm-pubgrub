[{"name":"Assignment","comment":" This is a helper module around `Assignment`,\nthe building block of a PubGrub partial solution\n(partial solution = the current state of the \"solution\" we are building in the algorithm).\n\n@docs Assignment, Kind\n\n@docs newDecision, newDerivation\n\n@docs getTerm, encodeDebug\n\n","unions":[{"name":"Kind","comment":" An assignment is either a decision, with the chosen version,\nor a derivation term, specifying compatible versions\naccording to previous assignments and all incompatibilities.\nWe also record the incompatibility responsible for\nthat derivation term as its \"cause\".\n","args":[],"cases":[["Decision",["Version.Version"]],["Derivation",["Term.Term","{ cause : Incompatibility.Incompatibility }"]]]}],"aliases":[{"name":"Assignment","comment":" An assignment refers to a given package and can either be\n(1) a decision, which is a chosen version,\nor (2) a derivation, which is a `Term` specifying compatible versions.\n\nA `decisionLevel` records how many decisions have already been taken,\nincluding this one if it is a decision.\n\n","args":[],"type":"{ package : String.String, decisionLevel : Basics.Int, kind : Assignment.Kind }"}],"values":[{"name":"encodeDebug","comment":" Encode an assignment into a JavaScript Value.\n","type":"Assignment.Assignment -> Json.Encode.Value"},{"name":"getTerm","comment":" Retrieve the current assignment as a `Term`.\nIf this is decision, it returns a positive term with that exact version.\nOtherwise, if this is a derivation, just returns its term.\n","type":"Assignment.Kind -> Term.Term"},{"name":"newDecision","comment":" Constructor for a decision.\n","type":"String.String -> Version.Version -> Basics.Int -> Assignment.Assignment"},{"name":"newDerivation","comment":" Constructor for a derivation.\n","type":"String.String -> Term.Term -> Basics.Int -> Incompatibility.Incompatibility -> Assignment.Assignment"}],"binops":[]},{"name":"Incompatibility","comment":" An incompatibility is a set of terms that should never\nbe satisfied all together.\nThis module provides functions to work with incompatibilities.\n\n@docs Incompatibility, asDict, notRoot, noVersion, unavailableDeps, fromDependencies, toDebugString\n\n\n# Composition of incompatibilities\n\n@docs merge, priorCause\n\n\n# Relation of satisfaction\n\n@docs Relation, relation\n\n\n# Error reporting\n\n@docs toReportTree\n\n\n# Other helper functions\n\n@docs isTerminal\n\n","unions":[{"name":"Incompatibility","comment":" An incompatibility is a set of terms that should never\nbe satisfied all together.\n\nAn incompatibility usually originated from a package dependency.\nFor example, if package A at version 1 depends on package B\nat version 2, you can never have both terms `A = 1`\nand `not B = 2` satisfied at the same time in a partial solution.\nThis would mean that we found a solution with package A at version 1\nbut not with package B at version 2.\nYet A@1 depends on B@2 so this is not possible.\nTherefore, the set `{ A = 1, not B = 2 }` is an incompatibility.\n\nIncompatibilities can also be derived from two other incompatibilities\nduring conflict resolution. More about all this in\n[PubGrub documentation](https://github.com/dart-lang/pub/blob/master/doc/solver.md#incompatibility).\n\nThis type holds a dual implementation for efficient runtime.\nBoth a temporally ordered list of terms,\nand an organized dictionary of packages are useful\nat different moments in the PubGrub algorithm.\n\n","args":[],"cases":[]},{"name":"Relation","comment":" A Relation describes how a set of terms can be compared to an incompatibility.\n\nWe say that a set of terms S satisfies an incompatibility I\nif S satisfies every term in I.\nWe say that S contradicts I\nif S contradicts at least one term in I.\nIf S satisfies all but one of I's terms and is inconclusive for the remaining term,\nwe say S \"almost satisfies\" I and we call the remaining term the \"unsatisfied term\".\nOtherwise, we say that their relation is inconclusive.\n\n","args":[],"cases":[["Satisfies",[]],["AlmostSatisfies",["String.String","Term.Term"]],["Contradicts",["String.String","Term.Term"]],["Inconclusive",[]]]}],"aliases":[],"values":[{"name":"asDict","comment":" Retrieve the dictionary representation of an incompatibility.\n","type":"Incompatibility.Incompatibility -> Dict.Dict String.String Term.Term"},{"name":"fromDependencies","comment":" Generate a list of incompatibilities from direct dependencies of a package.\nDependencies MUST be unique (no duplicate package name)\ndue to usage of insert here.\n","type":"String.String -> Version.Version -> List.List ( String.String, Range.Range ) -> List.List Incompatibility.Incompatibility"},{"name":"isTerminal","comment":" Check if an incompatibility should mark the end of the algorithm\nbecause of an issue.\n","type":"String.String -> Incompatibility.Incompatibility -> Basics.Bool"},{"name":"merge","comment":" Add incompatibilities obtained from dependencies in to the set of incompatibilities.\n\nPubgrub collapses identical dependencies from adjacent package versions\ninto individual incompatibilities.\nThis substantially reduces the total number of incompatibilities\nand makes it much easier for Pubgrub to reason about multiple versions of packages at once.\nFor example, rather than representing\nfoo 1.0.0 depends on bar ^1.0.0 and\nfoo 1.1.0 depends on bar ^1.0.0\nas two separate incompatibilities,\nthey're collapsed together into the single incompatibility {foo ^1.0.0, not bar ^1.0.0}\n(provided that no other version of foo exists between 1.0.0 and 2.0.0).\n\nHere we do the simple stupid thing of just growing the list.\nTODO: improve this. It may not be trivial since those incompatibilities\nmay already have derived others.\nMaybe this should not be persued.\n\n","type":"Incompatibility.Incompatibility -> List.List Incompatibility.Incompatibility -> List.List Incompatibility.Incompatibility"},{"name":"noVersion","comment":" Create an incompatibility to remember that a given range\ndoes not contain any version.\n","type":"String.String -> Term.Term -> Incompatibility.Incompatibility"},{"name":"notRoot","comment":" Create the initial \"not root\" incompatibility.\n","type":"String.String -> Version.Version -> Incompatibility.Incompatibility"},{"name":"priorCause","comment":" A prior cause is computed as the union of\nthe terms in the incompatibility and the terms in the satisfier's cause\nminus the terms referring to satisfier's package.\n","type":"Incompatibility.Incompatibility -> Incompatibility.Incompatibility -> Incompatibility.Incompatibility"},{"name":"relation","comment":" We say that a set of terms S satisfies an incompatibility I\nif S satisfies every term in I.\nWe say that S contradicts I\nif S contradicts at least one term in I.\nIf S satisfies all but one of I's terms and is inconclusive for the remaining term,\nwe say S \"almost satisfies\" I and we call the remaining term the \"unsatisfied term\".\n","type":"Dict.Dict String.String (List.List Term.Term) -> Incompatibility.Incompatibility -> Incompatibility.Relation"},{"name":"toDebugString","comment":" String representation of an incompatibility,\nfor debug means.\n","type":"Basics.Int -> Basics.Int -> Incompatibility.Incompatibility -> String.String"},{"name":"toReportTree","comment":" Convert an incompatibility into a tree useful for error reporting.\n","type":"Incompatibility.Incompatibility -> Report.Tree"},{"name":"unavailableDeps","comment":" Create an incompatibility to remember that a package version\nis not selectable because its list of dependencies is unavailable.\n","type":"String.String -> Version.Version -> Incompatibility.Incompatibility"}],"binops":[]},{"name":"Memory","comment":" A Memory acts like a structured partial solution\nwhere terms are regrouped by package in a dictionary.\nThis module provides functions to manage it.\n\n@docs Memory, PackageAssignments\n\n\n# Building a Memory\n\n@docs fromDecision, fromDerivation, addAssignment, addDecision, addDerivation\n\n\n# Retrieving terms in a Memory\n\n@docs terms\n\n\n# Finding a solution\n\n@docs potentialPackages, solution\n\n","unions":[],"aliases":[{"name":"Memory","comment":" Memory is the set of all assignments previous to (including)\nits paired assignment in the partial solution list.\n\nThose previous assignments are regrouped by package,\nmaking it easier to find out if a decision was made for a given package,\nand to list all corresponding derivations of a package.\n\nContrary to PartialSolution, Memory does not store derivations causes,\nonly the terms.\n\n","args":[],"type":"Dict.Dict String.String Memory.PackageAssignments"},{"name":"PackageAssignments","comment":" A package memory contains the potential decision and derivations\nthat have already been made for a given package.\n","args":[],"type":"{ decision : Maybe.Maybe Version.Version, derivations : List.List Term.Term }"}],"values":[{"name":"addAssignment","comment":" Building step of a Memory from a given assignment.\n","type":"Assignment.Assignment -> Memory.Memory -> Memory.Memory"},{"name":"addDecision","comment":" Add a decision to a Memory.\n","type":"String.String -> Version.Version -> Memory.Memory -> Memory.Memory"},{"name":"addDerivation","comment":" Add a derivation to a Memory.\n","type":"String.String -> Term.Term -> Memory.Memory -> Memory.Memory"},{"name":"fromDecision","comment":" Initialize a Memory from a decision.\n","type":"String.String -> Version.Version -> Memory.Memory"},{"name":"fromDerivation","comment":" Initialize a Memory from a derivation.\n","type":"String.String -> Term.Term -> Memory.Memory"},{"name":"potentialPackages","comment":" Extract all packages that may potentially be picked next\nto continue solving package dependencies.\nA package is a potential pick if there isn't an already\nversion selected (no \"decision\")\nand if it contains at least one positive derivation term\nin the partial solution.\n","type":"Memory.Memory -> Dict.Dict String.String (List.List Term.Term)"},{"name":"solution","comment":" If a partial solution has, for every positive derivation,\na corresponding decision that satisfies that assignment,\nit's a total solution and version solving has succeeded.\n","type":"Memory.Memory -> Maybe.Maybe (List.List ( String.String, Version.Version ))"},{"name":"terms","comment":" Retrieve all terms in memory.\n","type":"Memory.Memory -> Dict.Dict String.String (List.List Term.Term)"}],"binops":[]},{"name":"PartialSolution","comment":" The partial solution is the current state of our solution.\nThis module provides functions to manage it.\n\n@docs PartialSolution, empty, toDebugString\n\n\n# Final solution\n\n@docs solution\n\n\n# Building and backtracking a partial solution\n\n@docs prependDecision, prependDerivation, backtrack\n\n\n# Choosing a new package\n\n@docs potentialPackages, addVersion, relation\n\n\n# Satisfiers\n\n@docs findSatisfier, findPreviousSatisfier\n\n","unions":[{"name":"PartialSolution","comment":" The partial solution is the current state of our solution.\nIt is composed by a succession of assignments,\nwhich are either decisions or derivations.\n\nInternally, it has a dual representation in our implementation.\nA list enables fast backtracking into a previous correct state\nwhen solving conflicts,\nand a memory dictionary is useful in other parts of the algorithm\nrequiring fast access to a given package in previous assignments.\nIt could be fun to benchmark to check that it is actually useful.\n\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"addVersion","comment":" We can add the version to the partial solution as a decision\nif it doesn't produce any conflict with the new incompatibilities.\nIn practice I think it can only produce a conflict if one of the dependencies\n(which are used to make the new incompatibilities)\nis already in the partial solution with an incompatible version.\n","type":"String.String -> Version.Version -> List.List Incompatibility.Incompatibility -> PartialSolution.PartialSolution -> Maybe.Maybe PartialSolution.PartialSolution"},{"name":"backtrack","comment":" Backtrack the partial solution to a given decision level.\n","type":"Basics.Int -> PartialSolution.PartialSolution -> PartialSolution.PartialSolution"},{"name":"empty","comment":" Initialization of a partial solution.\n","type":"PartialSolution.PartialSolution"},{"name":"findPreviousSatisfier","comment":" Earliest assignment in the partial solution before satisfier\nsuch that incompatibility is satisfied by the partial solution up to\nand including that assignment plus satisfier.\n","type":"Assignment.Assignment -> Incompatibility.Incompatibility -> PartialSolution.PartialSolution -> Maybe.Maybe ( Assignment.Assignment, PartialSolution.PartialSolution, Term.Term )"},{"name":"findSatisfier","comment":" A satisfier is the earliest assignment in partial solution such that the incompatibility\nis satisfied by the partial solution up to and including that assignment.\nAlso returns all assignments earlier than the satisfier.\nWe call the term in the incompatibility that refers to the same package \"term\".\n","type":"Incompatibility.Incompatibility -> PartialSolution.PartialSolution -> ( Assignment.Assignment, PartialSolution.PartialSolution, Term.Term )"},{"name":"potentialPackages","comment":" Extract all packages that may potentially be picked next\nto continue solving package dependencies.\nA package is a potential pick if there isn't an already\nversion selected (no \"decision\")\nand if it contains at least one positive derivation term\nin the partial solution.\n","type":"PartialSolution.PartialSolution -> Dict.Dict String.String (List.List Term.Term)"},{"name":"prependDecision","comment":" Prepend a decision (a package with a version)\nto the partial solution.\n","type":"String.String -> Version.Version -> PartialSolution.PartialSolution -> PartialSolution.PartialSolution"},{"name":"prependDerivation","comment":" Prepend a package derivation term to the partial solution.\nAlso includes its cause.\n","type":"String.String -> Term.Term -> Incompatibility.Incompatibility -> PartialSolution.PartialSolution -> PartialSolution.PartialSolution"},{"name":"relation","comment":" Check if the terms in the partial solution\nsatisfy the incompatibility.\n","type":"Incompatibility.Incompatibility -> PartialSolution.PartialSolution -> Incompatibility.Relation"},{"name":"solution","comment":" If a partial solution has, for every positive derivation,\na corresponding decision that satisfies that assignment,\nit's a total solution and version solving has succeeded.\n","type":"PartialSolution.PartialSolution -> Maybe.Maybe (List.List ( String.String, Version.Version ))"},{"name":"toDebugString","comment":" Printable String version of a partial solution,\nfor debug purposes.\n","type":"PartialSolution.PartialSolution -> String.String"}],"binops":[]},{"name":"PubGrub","comment":" PubGrub version solving algorithm.\n\nIt consists in efficiently finding a set of packages and versions\nthat satisfy all the constraints of a given project dependencies.\nIn addition, when that is not possible,\nPubGrub tries to provide a very human-readable and clear\nexplaination as to why that failed.\nBelow is an example of explanation present in\nthe introductory blog post about PubGrub\n(elm-pubgrub is almost there ^^).\n\n```txt\nBecause dropdown >=2.0.0 depends on icons >=2.0.0 and\n  root depends on icons <2.0.0, dropdown >=2.0.0 is forbidden.\n\nAnd because menu >=1.1.0 depends on dropdown >=2.0.0,\n  menu >=1.1.0 is forbidden.\n\nAnd because menu <1.1.0 depends on dropdown >=1.0.0 <2.0.0\n  which depends on intl <4.0.0, every version of menu\n  requires intl <4.0.0.\n\nSo, because root depends on both menu >=1.0.0 and intl >=5.0.0,\n  version solving failed.\n```\n\nThe algorithm is generic and works for any type of dependency system\nwith the following caracteristics, not only Elm packages.\n\n  - Versions use the semantic versioning scheme (Major.Minor.Patch).\n  - Packages cannot be simultaneously present at two different versions.\n  - Dependencies are expressed in one of the following forms\n      - exact version (`foo 1.0.0 depends bar 1.0.0`)\n      - higher or equal version (`foo 1.0.0 depends on bar >= 1.0.0`)\n      - stricly lower version (`foo 1.0.0 depends on bar < 2.0.0`)\n      - ranges of versions (`foo 1.0.0 depends on bar 1.0.0 <= v < 2.0.0`)\n\nPS: at publication, only the `PubGrub`, `Version`, `Range`, and `Term`\nmodules will be exposed.\nOthers are exposed for easy docs usage at the moment.\n\n\n## API\n\nThe algorithm is provided in two forms, synchronous and asynchronous.\nThe synchronous API is quite straightforward.\nThe async one uses the `Effect` pattern to be easily integrated\ninto the TEA architecture.\n\n\n### Direct sync call\n\n    PubGrub.solve config package version\n\nWhere config provides the list of available packages and versions,\nas well as the dependencies of every available package.\nThe call to `PubGrub.solve` for a given package at a given version\nwill compute the set of packages and versions needed.\n\n\n### Async API\n\nSometimes, it is too expensive to provide upfront\nthe list of all packages and versions,\nas well as all dependencies for every one of those.\nThis may very well require some network or other async requests.\nFor this reason, it is possible to run the PubGrub algorithm step by step.\nEvery time an effect may be required, it stops and informs the caller,\nwhich may resume the algorithm once necessary data is loaded.\n\n    PubGrub.update : Connectivity -> Cache -> Msg -> State -> ( State, Effect )\n\nThe `Effect` type is public to enable the caller to perform\nthe required task before resuming.\nThe `Msg` type is also public to drive the algorithm according\nto what was expected in the last effect when resuming.\n\nAt any point between two `update` calls,\nthe caller can change the `Connectivity`\nand update the `Cache` of already loaded data.\n\nThe algorithm informs the caller that all is done\nwhen the `SignalEnd result` effect is emitted.\n\n\n# Common to sync and async\n\n@docs Solution\n\n\n# Sync\n\n@docs PackagesConfig, solve\n\n\n# Async\n\n@docs State, stateToString, Effect, effectToString, Msg\n@docs Connectivity, init, update\n@docs Cache, emptyCache, cacheDependencies, cachePackageVersions\n\n","unions":[{"name":"Cache","comment":" Cache holding already loaded packages information.\n","args":[],"cases":[]},{"name":"Connectivity","comment":" Online or Offline.\n\nIn Offline mode, the `ListVersions` effect is never emitted\nbecause we never know if a new version or not may be available,\nand thus if the cache contains or not all available versions.\nIt will always use the list of versions available in cache.\n\nIn Offline mode, the `RetrieveDependencies` effect is never emitted.\nEither the dependencies are known and it will continue,\nor they aren't and it will signal a failure.\n\n","args":[],"cases":[["Online",[]],["Offline",[]]]},{"name":"Effect","comment":" Those are the effects required by the PubGrub algorithm.\nOnce emitted, they may require you to retrieve some data,\nand then send the adequate message to the algorithm.\n","args":[],"cases":[["NoEffect",[]],["ListVersions",["( String.String, Term.Term )"]],["RetrieveDependencies",["( String.String, Version.Version )"]],["SignalEnd",["Result.Result String.String PubGrub.Solution"]]]},{"name":"Msg","comment":" Messages used to progress in the algorithm.\n\nYou should pick the one you need depending on the last effect emitted.\nFor example, the `ListVersions` effect is asking you to retrieve\navailable versions for a given package.\nOnce done, inform PubGrub with the `AvailableVersions` message\n(and pass around the `Term` value).\n\n","args":[],"cases":[["NoMsg",[]],["AvailableVersions",["String.String","Term.Term","List.List Version.Version"]],["PackageDependencies",["String.String","Version.Version","Maybe.Maybe (List.List ( String.String, Range.Range ))"]]]},{"name":"State","comment":" Internal state of the PubGrub algorithm.\n","args":[],"cases":[]}],"aliases":[{"name":"PackagesConfig","comment":" Configuration of available packages to solve dependencies.\n","args":[],"type":"{ listAvailableVersions : String.String -> List.List Version.Version, getDependencies : String.String -> Version.Version -> Maybe.Maybe (List.List ( String.String, Range.Range )) }"},{"name":"Solution","comment":" Solution of the algorithm containing the list of required packages\nwith their version number.\n","args":[],"type":"List.List ( String.String, Version.Version )"}],"values":[{"name":"cacheDependencies","comment":" Add dependencies of a package to the cache.\n","type":"String.String -> Version.Version -> List.List ( String.String, Range.Range ) -> PubGrub.Cache -> PubGrub.Cache"},{"name":"cachePackageVersions","comment":" Add a list of packages and versions to the cache.\n","type":"List.List ( String.String, Version.Version ) -> PubGrub.Cache -> PubGrub.Cache"},{"name":"effectToString","comment":" Convert an effect into a printable string (for human reading).\n","type":"PubGrub.Effect -> String.String"},{"name":"emptyCache","comment":" Initial empty cache.\n","type":"PubGrub.Cache"},{"name":"init","comment":" Initialize PubGrub algorithm.\n","type":"PubGrub.Connectivity -> PubGrub.Cache -> String.String -> Version.Version -> ( PubGrub.State, PubGrub.Effect )"},{"name":"solve","comment":" PubGrub version solving algorithm.\n","type":"PubGrub.PackagesConfig -> String.String -> Version.Version -> Result.Result String.String PubGrub.Solution"},{"name":"stateToString","comment":" Convert a state into a printable string (for human reading).\n","type":"PubGrub.State -> String.String"},{"name":"update","comment":" Update the state of the PubGrub algorithm.\n","type":"PubGrub.Connectivity -> PubGrub.Cache -> PubGrub.Msg -> PubGrub.State -> ( PubGrub.State, PubGrub.Effect )"}],"binops":[]},{"name":"PubGrubCore","comment":" PubGrub version solving algorithm.\n\nPubGrub is a version solving algorithm,\nwritten in 2018 by Natalie Weizenbaum\nfor the Dart package manager.\nIt is supposed to be very fast and to explain errors\nmore clearly than the alternatives.\nAn introductory blog post was\n[published on Medium][medium-pubgrub] by its author.\n\nThe detailed explanation of the algorithm is\n[provided on GitHub][github-pubgrub].\nThe foundation of the algorithm is based on ASP (Answer Set Programming)\nand a book called\n\"[Answer Set Solving in Practice][potassco-book]\"\nby Martin Gebser, Roland Kaminski, Benjamin Kaufmann and Torsten Schaub.\n\n[medium-pubgrub]: https://medium.com/@nex3/pubgrub-2fb6470504f\n[github-pubgrub]: https://github.com/dart-lang/pub/blob/master/doc/solver.md\n[potassco-book]: https://potassco.org/book/\n\nThis module contains the core model and functions\nto write a functional PubGrub algorithm.\n\n@docs Model\n\n@docs init, setIncompatibilities, mapIncompatibilities\n\n@docs pickPackage, pickVersion, unitPropagation\n\n","unions":[],"aliases":[{"name":"Model","comment":" PubGrub model.\n","args":[],"type":"{ incompatibilities : List.List Incompatibility.Incompatibility, partialSolution : PartialSolution.PartialSolution }"}],"values":[{"name":"init","comment":" PubGrub init.\n","type":"String.String -> Version.Version -> PubGrubCore.Model"},{"name":"mapIncompatibilities","comment":" PubGrub mapIncompatibilities.\n","type":"(List.List Incompatibility.Incompatibility -> List.List Incompatibility.Incompatibility) -> PubGrubCore.Model -> PubGrubCore.Model"},{"name":"pickPackage","comment":" Heuristic to pick the next package to add to the partial solution.\nThis should be a package with a positive derivation but no decision yet.\nIf multiple choices are possible, use a heuristic.\n\nPub chooses the package with the fewest versions\nmatching the outstanding constraint.\nThis tends to find conflicts earlier if any exist,\nsince these packages will run out of versions to try more quickly.\nBut there's likely room for improvement in these heuristics.\n\nHere we just pick the first one.\nTODO: improve?\n\n","type":"PartialSolution.PartialSolution -> Maybe.Maybe ( String.String, Term.Term )"},{"name":"pickVersion","comment":" Pub chooses the latest matching version of the package\nthat match the outstanding constraint.\n\nHere we just pick the first one that satisfies the terms.\nIt is the responsibility of the provider of `availableVersions`\nto list them with preferred versions first.\n\n","type":"List.List Version.Version -> Term.Term -> Maybe.Maybe Version.Version"},{"name":"setIncompatibilities","comment":" PubGrub setIncompatibilities.\n","type":"List.List Incompatibility.Incompatibility -> PubGrubCore.Model -> PubGrubCore.Model"},{"name":"unitPropagation","comment":" Unit propagation is the core mechanism of the solving algorithm.\n","type":"String.String -> String.String -> PubGrubCore.Model -> Result.Result String.String PubGrubCore.Model"}],"binops":[]},{"name":"Range","comment":" Dealing with version ranges union and intersection.\n\n@docs Range, toDebugString\n\n\n# Creation of a range selection\n\n@docs none, any, exact, higherThan, lowerThan, between\n\n\n# Set operations on ranges\n\n@docs negate, intersection, union\n\n\n# Evaluate if a range contains a given version\n\n@docs contains\n\n","unions":[{"name":"Range","comment":" A range corresponds to any set of versions\nrepresentable as a concatenation, union, and complement\nof version ranges building blocks.\n\nThose building blocks are:\n\n  - `none`: the empty set\n  - `any`: the set of all possible versions\n  - `exact v`: the singleton set of only version `v`\n  - `higherThan v`: the set of versions higher or equal to `v`\n  - `lowerThan v`: the set of versions strictly lower than `v`\n  - `between v1 v2`: the set of versions higher or equal\n    to `v1` and strictly lower than `v2`\n\nInternally, they are represented as an ordered list of intervals\nto have a normalized form enabling comparisons of ranges.\n\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"any","comment":" Set of all possible versions.\n\n    any == higherThan zero\n\n","type":"Range.Range"},{"name":"between","comment":" Set of versions comprised between two given versions.\nThe lower bound is included and the higher bound excluded.\n`v1 <= v < v2`.\n\n    between v1 v2 == intersection (higherThan v1) (lowerThan v2)\n\n","type":"Version.Version -> Version.Version -> Range.Range"},{"name":"contains","comment":" Check if a range selection contains a given version.\n","type":"Version.Version -> Range.Range -> Basics.Bool"},{"name":"exact","comment":" Set containing exactly one version.\n\n    exact v == intersection (higherThan v) (lowerThan <| bumpPatch v)\n\n","type":"Version.Version -> Range.Range"},{"name":"higherThan","comment":" Set of all versions higher or equal to some version.\n","type":"Version.Version -> Range.Range"},{"name":"intersection","comment":" Compute intersection of two sets of versions.\n","type":"Range.Range -> Range.Range -> Range.Range"},{"name":"lowerThan","comment":" Set of all versions strictly lower than some version.\n","type":"Version.Version -> Range.Range"},{"name":"negate","comment":" Compute the complement set of versions.\n","type":"Range.Range -> Range.Range"},{"name":"none","comment":" Empty set of versions.\n\n    none == lowerThan zero\n\n","type":"Range.Range"},{"name":"toDebugString","comment":" Displayable representation of a range, for debug purposes\n","type":"Range.Range -> String.String"},{"name":"union","comment":" Compute union of two sets of versions.\n","type":"Range.Range -> Range.Range -> Range.Range"}],"binops":[]},{"name":"Report","comment":" Module dealing with the textual reporting of the issue\nwhen the solver failed, in the most human-readable possible way.\n\n@docs Tree, generate\n\n@docs DerivedIncompat, Incompat, Kind\n\nSome remarks related to the algorithms below.\n\nWe give a ref number to a line either:\n\n  - because the second branch is also long\n  - or because it causes two or more derived incompats\n\nA derived can only \"already\" have a line number ref\nif it is one that causes two or more derived incompatibilities.\nOtherwise, it is necessarily the first (and only) time that we see the node,\nand thus it cannot already have been marked with a line number.\n\nSo in practice, there is no need to save all lines that have been numberRef\nbecause only those for shared nodes will be reused later.\n\n","unions":[{"name":"Kind","comment":" External incompatibilities are of different kinds.\nIt may be that no version exist in a given range,\nor the dependencies of a given package are not available,\nor simply, it may traduct a package dependency.\n","args":[],"cases":[["NoVersion",[]],["UnavailableDependencies",[]],["Dependencies",[]]]},{"name":"Tree","comment":" Tree of incompatibilities leading to the root one.\n","args":[],"cases":[["Derived",["Report.DerivedIncompat"]],["External",["Report.Incompat","Report.Kind"]]]}],"aliases":[{"name":"DerivedIncompat","comment":" Incompatibility derived from two others.\nIt may be marked as \"shared\" if it is present multiple times\nin the derivation tree.\n","args":[],"type":"{ incompat : Report.Incompat, shared : Basics.Bool, cause1 : Report.Tree, cause2 : Report.Tree }"},{"name":"Incompat","comment":" Just an alias for type definitions.\n","args":[],"type":"List.List ( String.String, Term.Term )"}],"values":[{"name":"generate","comment":" Generate a human-readable textual report from a derivation tree.\n","type":"Report.Tree -> String.String"}],"binops":[]},{"name":"Term","comment":" A term is the fundamental unit of operation of the PubGrub algorithm.\nIt is a positive or negative expression regarding a selection of versions.\nThis module exposes types and functions to deal with terms.\n\n@docs Term, isPositive, negate, toDebugString\n\n@docs acceptVersion, acceptVersionJust\n\n\n# Set operations with terms\n\n@docs intersection, union, listIntersection\n\n\n# Relation between terms\n\n@docs Relation, satisfies, contradicts, relation\n\n","unions":[{"name":"Relation","comment":" Describe a relation between a term and another set of terms.\nHere is a description extracted from PubGrub documentation.\n\nWe say that a set of terms S \"satisfies\"\na term t if t must be true whenever every term in S is true.\nConversely, S \"contradicts\" t if t must be false\nwhenever every term in S is true.\nIf neither of these is true\nwe say that S is \"inconclusive\" for t.\nAs a shorthand, we say that\na term v satisfies or contradicts t if\n{v} satisfies or contradicts it.\n\n","args":[],"cases":[["Satisfies",[]],["Contradicts",[]],["Inconclusive",[]]]},{"name":"Term","comment":" A positive or negative expression regarding a selection of versions.\n\nFor example, \"1.0.0 <= v < 2.0.0\" is a positive expression\nthat is evaluated true if a version is selected and\ncomprised between version 1.0.0 and version 2.0.0.\nThe term \"not v < 3.0.0\" is a negative expression\nthat is evaluated true if a version is selected >= 3.0.0\nor if no version is selected at all.\n\n","args":[],"cases":[["Positive",["Range.Range"]],["Negative",["Range.Range"]]]}],"aliases":[],"values":[{"name":"acceptVersion","comment":" Evaluate a term regarding a given choice\n(or absence of choice) of a version.\n","type":"Maybe.Maybe Version.Version -> Term.Term -> Basics.Bool"},{"name":"acceptVersionJust","comment":" Evaluate a term regarding a given choice of version.\n","type":"Version.Version -> Term.Term -> Basics.Bool"},{"name":"contradicts","comment":" Check if a set of terms contradicts a given term.\n\nWe say that a set of terms S \"contradicts\"\na term t if t must be false whenever every term in S is true.\n\n","type":"Term.Term -> List.List Term.Term -> Basics.Bool"},{"name":"intersection","comment":" Compute the intersection of two terms.\nIf at least one term is positive,\nthe intersection is a positive term.\n","type":"Term.Term -> Term.Term -> Term.Term"},{"name":"isPositive","comment":" Simply check if a term is positive.\n","type":"Term.Term -> Basics.Bool"},{"name":"listIntersection","comment":" Compute the intersection of a list of terms.\nAn initial term may be provided.\nOtherwise `not ∅` will be used as initialization for the intersection.\n\nWondering if it would be better to return a Maybe Term\nand let the caller decide what should mean\nthe intersection of an empty list of terms.\n\n","type":"Maybe.Maybe Term.Term -> List.List Term.Term -> Term.Term"},{"name":"negate","comment":" Negate a term.\nEvaluation of a negated term always returns the opposite\nof the evaluation of the original one.\n","type":"Term.Term -> Term.Term"},{"name":"relation","comment":" Check if a set of terms satisfies or contradicts\na given term. Otherwise the relation is inconclusive.\n","type":"Term.Term -> List.List Term.Term -> Term.Relation"},{"name":"satisfies","comment":" Check if a set of terms satisfies a given term.\n\nWe say that a set of terms S \"satisfies\"\na term t if t must be true whenever every term in S is true.\n\n","type":"Term.Term -> List.List Term.Term -> Basics.Bool"},{"name":"toDebugString","comment":" String representation of a term, for debug purposes.\n","type":"Term.Term -> String.String"},{"name":"union","comment":" Compute the union of two terms.\nIf at least one term is positive,\nthe union is a positive term.\n","type":"Term.Term -> Term.Term -> Term.Term"}],"binops":[]},{"name":"Version","comment":" Versions following the semantic versioning scheme of\nMajor.Minor.Patch.\nThis module provides functions to create and compare versions.\n\n@docs Version, toDebugString, toTuple\n\n\n# Predefined versions\n\n@docs zero, one, two, three\n\n\n# Create a new version\n\n@docs new, new_, fromTuple\n\n\n# Bump versions\n\n@docs bumpPatch, bumpMinor, bumpMajor\n\n\n# Compare versions\n\n@docs max, min, higherThan, lowerThan\n\n","unions":[{"name":"Version","comment":" Type for semantic versions.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"bumpMajor","comment":" Bump major number of a version.\n\n    bumpMajor (new_ 1 0 3) == new_ 2 0 0\n\n","type":"Version.Version -> Version.Version"},{"name":"bumpMinor","comment":" Bump minor number of a version.\n\n    bumpMinor (new_ 1 0 3) == new_ 1 1 0\n\n","type":"Version.Version -> Version.Version"},{"name":"bumpPatch","comment":" Bump patch number of a version.\n\n    bumpPatch (new_ 1 0 3) == new_ 1 0 4\n\n","type":"Version.Version -> Version.Version"},{"name":"fromTuple","comment":" Alternative constructor from a tuple.\n\n    fromTuple ( mj, mn, p ) == new_ mj mn p\n\n","type":"( Basics.Int, Basics.Int, Basics.Int ) -> Version.Version"},{"name":"higherThan","comment":" Check if a version is strictly higher than another version.\n","type":"Version.Version -> Version.Version -> Basics.Bool"},{"name":"lowerThan","comment":" Check if a version is strictly lower than another version.\n","type":"Version.Version -> Version.Version -> Basics.Bool"},{"name":"max","comment":" Return the highest of two versions.\n","type":"Version.Version -> Version.Version -> Version.Version"},{"name":"min","comment":" Return the lowest of two versions.\n","type":"Version.Version -> Version.Version -> Version.Version"},{"name":"new","comment":" Create a version with the given major, minor,\nand patch values `v = major.minor.patch`.\nNegative values are set to 0.\n","type":"{ major : Basics.Int, minor : Basics.Int, patch : Basics.Int } -> Version.Version"},{"name":"new_","comment":" Alternative constructor.\n\n    new_ mj mn p == new { major = mj, minor = mn, patch = p }\n\n","type":"Basics.Int -> Basics.Int -> Basics.Int -> Version.Version"},{"name":"one","comment":" Version 1.0.0\n","type":"Version.Version"},{"name":"three","comment":" Version 3.0.0\n","type":"Version.Version"},{"name":"toDebugString","comment":" Displayable String representation of versions, for debug purposes.\n","type":"Version.Version -> String.String"},{"name":"toTuple","comment":" Retrieve a version as a tuple.\n","type":"Version.Version -> ( Basics.Int, Basics.Int, Basics.Int )"},{"name":"two","comment":" Version 2.0.0\n","type":"Version.Version"},{"name":"zero","comment":" Version 0.0.0\n","type":"Version.Version"}],"binops":[]}]