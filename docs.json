[{"name":"Assignment","comment":" This is a helper module around `Assignment`,\nthe building block of a PubGrub partial solution\n(partial solution = the current state of the \"solution\" we are building in the algorithm).\n\n@docs Assignment, Kind\n\n@docs newDecision, newDerivation\n\n@docs getTerm, encodeDebug\n\n","unions":[{"name":"Kind","comment":" An assignment is either a decision, with the chosen version,\nor a derivation term, specifying compatible versions\naccording to previous assignments and all incompatibilities.\nWe also record the incompatibility responsible for\nthat derivation term as its \"cause\".\n","args":[],"cases":[["Decision",["Version.Version"]],["Derivation",["Term.Term","{ cause : Incompatibility.Incompatibility }"]]]}],"aliases":[{"name":"Assignment","comment":" An assignment refers to a given package (`name : String`) and can either be\n(1) a decision, which is a chosen version,\nor (2) a derivation, which is a `Term` specifying compatible versions.\n\nA `decisionLevel` records how many decisions have already been taken,\nincluding this one if it is a decision.\n\n","args":[],"type":"{ name : String.String, decisionLevel : Basics.Int, kind : Assignment.Kind }"}],"values":[{"name":"encodeDebug","comment":" Encode an assignment into a JavaScript Value.\n","type":"Assignment.Assignment -> Json.Encode.Value"},{"name":"getTerm","comment":" Retrieve the current assignment as a `Term`.\nIf this is decision, it returns a positive term with that exact version.\nOtherwise, if this is a derivation, just returns its term.\n","type":"Assignment.Kind -> Term.Term"},{"name":"newDecision","comment":" Constructor for a decision.\n","type":"String.String -> Version.Version -> Basics.Int -> Assignment.Assignment"},{"name":"newDerivation","comment":" Constructor for a derivation.\n","type":"String.String -> Term.Term -> Basics.Int -> Incompatibility.Incompatibility -> Assignment.Assignment"}],"binops":[]},{"name":"Database.ElmJson","comment":" Pre-loaded package dependencies for most used Elm packages.\n(NOT USED YET, I'm still in the debugging stage with handcrafted\nexamples stored in Database.Stub.\n\n@docs Packages, init\n\n","unions":[],"aliases":[{"name":"Packages","comment":" Representation of the whole set of packages.\n","args":[],"type":"Dict.Dict ( String.String, ( Basics.Int, Basics.Int, Basics.Int ) ) Elm.Project.Project"}],"values":[{"name":"init","comment":" Initial set of preloaded packages.\n","type":"Database.ElmJson.Packages"}],"binops":[]},{"name":"Database.History","comment":" Pre-loaded history of all elm package versions.\nNOT USED YET, I'm still in the debugging phase,\nwith handcrafted examples in Database.Stub.\n\n@docs allPackages\n\n","unions":[],"aliases":[],"values":[{"name":"allPackages","comment":" List of all packages exisiting to this moment.\n","type":"Dict.Dict String.String (List.List Elm.Version.Version)"}],"binops":[]},{"name":"Derivation","comment":" Representation of the derivation of terms as a graph.\nNOT USED YET.\n\n@docs Graph\n\n","unions":[{"name":"Graph","comment":" Derivation graph.\n","args":[],"cases":[]}],"aliases":[],"values":[],"binops":[]},{"name":"Incompatibility","comment":" An incompatibility is a set of terms that should never\nbe satisfied all together.\nThis module provides functions to work with incompatibilities.\n\n@docs Incompatibility, asDict, fromTerm, fromDependencies, toDebugString\n\n\n# Composition of incompatibilities\n\n@docs insert, merge, priorCause\n\n\n# Relation of satisfaction\n\n@docs Relation, relation\n\n\n# Other helper functions\n\n@docs singlePositive\n\n","unions":[{"name":"Incompatibility","comment":" An incompatibility is a set of terms that should never\nbe satisfied all together.\n\nAn incompatibility usually originated from a package dependency.\nFor example, if package A at version 1 depends on package B\nat version 2, you can never have both terms `A = 1`\nand `not B = 2` satisfied at the same time in a partial solution.\nThis would mean that we found a solution with package A at version 1\nbut not with package B at version 2.\nYet A@1 depends on B@2 so this is not possible.\nTherefore, the set `{ A = 1, not B = 2 }` is an incompatibility.\n\nIncompatibilities can also be derived from two other incompatibilities\nduring conflict resolution. More about all this in\n[PubGrub documentation](https://github.com/dart-lang/pub/blob/master/doc/solver.md#incompatibility).\n\nThis type holds a dual implementation for efficient runtime.\nBoth a temporally ordered list of terms,\nand an organized dictionary of packages are useful\nat different moments in the PubGrub algorithm.\n\n","args":[],"cases":[]},{"name":"Relation","comment":" A Relation describes how a set of terms can be compared to an incompatibility.\n\nWe say that a set of terms S satisfies an incompatibility I\nif S satisfies every term in I.\nWe say that S contradicts I\nif S contradicts at least one term in I.\nIf S satisfies all but one of I's terms and is inconclusive for the remaining term,\nwe say S \"almost satisfies\" I and we call the remaining term the \"unsatisfied term\".\nOtherwise, we say that their relation is inconclusive.\n\n","args":[],"cases":[["Satisfies",[]],["AlmostSatisfies",["String.String","Term.Term"]],["Contradicts",["String.String","Term.Term"]],["Inconclusive",[]]]}],"aliases":[],"values":[{"name":"asDict","comment":" Retrieve the dictionary representation of an incompatibility.\n","type":"Incompatibility.Incompatibility -> Dict.Dict String.String Term.Term"},{"name":"fromDependencies","comment":" Generate a list of incompatibilities from direct dependencies of a package.\nDependencies MUST be unique (no duplicate package name)\ndue to usage of insert here.\n","type":"String.String -> Version.Version -> List.List ( String.String, Range.Range ) -> List.List Incompatibility.Incompatibility"},{"name":"fromTerm","comment":" Create a singleton incompatibility containing a unique term.\n","type":"String.String -> Term.Term -> Incompatibility.Incompatibility"},{"name":"insert","comment":" Insert a new package term inside an incompatibility.\nUse ONLY if guaranted that the package name is not already in the incompatibility.\n","type":"String.String -> Term.Term -> Incompatibility.Incompatibility -> Incompatibility.Incompatibility"},{"name":"merge","comment":" Add incompatibilities obtained from dependencies in to the set of incompatibilities.\n\nPubgrub collapses identical dependencies from adjacent package versions\ninto individual incompatibilities.\nThis substantially reduces the total number of incompatibilities\nand makes it much easier for Pubgrub to reason about multiple versions of packages at once.\nFor example, rather than representing\nfoo 1.0.0 depends on bar ^1.0.0 and\nfoo 1.1.0 depends on bar ^1.0.0\nas two separate incompatibilities,\nthey're collapsed together into the single incompatibility {foo ^1.0.0, not bar ^1.0.0}\n(provided that no other version of foo exists between 1.0.0 and 2.0.0).\n\nHere we do the simple stupid thing of just growing the list.\nTODO: improve this.\n\n","type":"Incompatibility.Incompatibility -> List.List Incompatibility.Incompatibility -> List.List Incompatibility.Incompatibility"},{"name":"priorCause","comment":" A prior cause is computed as the union of\nthe terms in the incompatibility and the terms in the satisfier's cause\nminus the terms referring to satisfier's package.\n","type":"String.String -> Incompatibility.Incompatibility -> Incompatibility.Incompatibility -> Incompatibility.Incompatibility"},{"name":"relation","comment":" We say that a set of terms S satisfies an incompatibility I\nif S satisfies every term in I.\nWe say that S contradicts I\nif S contradicts at least one term in I.\nIf S satisfies all but one of I's terms and is inconclusive for the remaining term,\nwe say S \"almost satisfies\" I and we call the remaining term the \"unsatisfied term\".\n\nTODO: reverse the Incompatibility and dict arguments order.\n\n","type":"Incompatibility.Incompatibility -> Dict.Dict String.String (List.List Term.Term) -> Incompatibility.Relation"},{"name":"singlePositive","comment":" Check if an incompatibility contains a single positive term\nrelated to the given package.\n","type":"String.String -> Incompatibility.Incompatibility -> Basics.Bool"},{"name":"toDebugString","comment":" String representation of an incompatibility,\nfor debug means.\n","type":"Basics.Int -> Basics.Int -> Incompatibility.Incompatibility -> String.String"}],"binops":[]},{"name":"PartialSolution","comment":" The partial solution is the current state of our solution.\nThis module provides functions to manage it.\n\n@docs PartialSolution, empty, toDebugString\n\n\n# Final solution\n\n@docs solution\n\n\n# Building and backtracking a partial solution\n\n@docs prependDecision, prependDerivation, dropUntilLevel\n\n\n# Choosing a new package\n\n@docs potentialPackages, addVersion, relation\n\n\n# Satisfiers\n\n@docs findSatisfier, findPreviousSatisfier\n\n","unions":[{"name":"PartialSolution","comment":" The partial solution is the current state of our solution.\nIt is composed by a succession of assignments,\nwhich are either decisions or derivations.\n\nInternally, it has a dual representation in our implementation.\nA list enables fast backtracking into a previous correct state\nwhen solving conflicts,\nand a memory dictionary is useful in other parts of the algorithm\nrequiring fast access to a given package in previous assignments.\nIt could be fun to benchmark to check that it is actually useful.\n\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"addVersion","comment":" We can add the version to the partial solution as a decision\nif it doesn't produce any conflict with the new incompatibilities.\nIn practice I think it can only produce a conflict if one of the dependencies\n(which are used to make the new incompatibilities)\nis already in the partial solution with an incompatible version.\n","type":"String.String -> Version.Version -> List.List Incompatibility.Incompatibility -> PartialSolution.PartialSolution -> Maybe.Maybe PartialSolution.PartialSolution"},{"name":"dropUntilLevel","comment":" Backtrack the partial solution to a given decision level.\n","type":"Basics.Int -> PartialSolution.PartialSolution -> PartialSolution.PartialSolution"},{"name":"empty","comment":" Initialization of a partial solution.\n","type":"PartialSolution.PartialSolution"},{"name":"findPreviousSatisfier","comment":" Earliest assignment in the partial solution before satisfier\nsuch that incompatibility is satisfied by the partial solution up to\nand including that assignment plus satisfier.\n","type":"Assignment.Assignment -> Incompatibility.Incompatibility -> PartialSolution.PartialSolution -> Maybe.Maybe ( Assignment.Assignment, PartialSolution.PartialSolution, Term.Term )"},{"name":"findSatisfier","comment":" A satisfier is the earliest assignment in partial solution such that the incompatibility\nis satisfied by the partial solution up to and including that assignment.\nAlso returns all assignments earlier than the satisfier.\nWe call the term in the incompatibility that refers to the same package \"term\".\n","type":"Incompatibility.Incompatibility -> PartialSolution.PartialSolution -> ( Assignment.Assignment, PartialSolution.PartialSolution, Term.Term )"},{"name":"potentialPackages","comment":" Extract all packages that may potentially be picked next\nto continue solving package dependencies.\nA package is a potential pick if there isn't an already\nversion selected (no \"decision\")\nand if it contains at least one positive derivation term\nin the partial solution.\n","type":"PartialSolution.PartialSolution -> Dict.Dict String.String (List.List Term.Term)"},{"name":"prependDecision","comment":" Prepend a decision (a package with a version)\nto the partial solution.\n","type":"String.String -> Version.Version -> PartialSolution.PartialSolution -> PartialSolution.PartialSolution"},{"name":"prependDerivation","comment":" Prepend a package derivation term to the partial solution.\nAlso includes its cause.\n","type":"String.String -> Term.Term -> Incompatibility.Incompatibility -> PartialSolution.PartialSolution -> PartialSolution.PartialSolution"},{"name":"relation","comment":" Check if the terms in the partial solution\nsatisfy the incompatibility.\n\nTODO: why am I not using List.map (Tuple.first >> Assignment.getTerm)?\nProbably because I need a Dict for Incompatibility.relation ...\n\n","type":"Incompatibility.Incompatibility -> PartialSolution.PartialSolution -> Incompatibility.Relation"},{"name":"solution","comment":" If a partial solution has, for every positive derivation,\na corresponding decision that satisfies that assignment,\nit's a total solution and version solving has succeeded.\n","type":"PartialSolution.PartialSolution -> Maybe.Maybe (List.List ( String.String, Version.Version ))"},{"name":"toDebugString","comment":" Printable String version of a partial solution,\nfor debug purposes.\n","type":"PartialSolution.PartialSolution -> String.String"}],"binops":[]},{"name":"PubGrub","comment":" PubGrub version solving algorithm.\n\nPubGrub is a version solving algorithm,\nwritten in 2018 by Natalie Weizenbaum\nfor the Dart package manager.\nIt is supposed to be very fast and to explain errors\nmore clearly than the alternatives.\nAn introductory blog post was\n[published on Medium][medium-pubgrub] by its author.\n\nThe detailed explanation of the algorithm is\n[provided on GitHub][github-pubgrub].\nThe foundation of the algorithm is based on ASP (Answer Set Programming)\nand a book called\n\"[Answer Set Solving in Practice][potassco-book]\"\nby Martin Gebser, Roland Kaminski, Benjamin Kaufmann and Torsten Schaub.\n\n[medium-pubgrub]: https://medium.com/@nex3/pubgrub-2fb6470504f\n[github-pubgrub]: https://github.com/dart-lang/pub/blob/master/doc/solver.md\n[potassco-book]: https://potassco.org/book/\n\n@docs solve\n\n","unions":[],"aliases":[],"values":[{"name":"solve","comment":" PubGrub version solving algorithm.\n","type":"String.String -> Version.Version -> Result.Result String.String (List.List ( String.String, Version.Version ))"}],"binops":[]},{"name":"Range","comment":" Dealing with version ranges union and intersection.\n\n@docs Range, toDebugString\n\n\n# Creation of a range selection\n\n@docs none, any, exact, higherThan, lowerThan, between\n\n\n# Set operations on ranges\n\n@docs negate, intersection, union\n\n\n# Evaluate if a range contains a given version\n\n@docs contains\n\n","unions":[{"name":"Range","comment":" A range corresponds to any set of versions\nrepresentable as a concatenation, union, and complement\nof version ranges building blocks.\n\nThose building blocks are:\n\n  - `none`: the empty set\n  - `any`: the set of all possible versions\n  - `exact v`: the singleton set of only version `v`\n  - `higherThan v`: the set of versions higher or equal to `v`\n  - `lowerThan v`: the set of versions strictly lower than `v`\n  - `between v1 v2`: the set of versions higher or equal\n    to `v1` and strictly lower than `v2`\n\nInternally, they are represented as an ordered list of intervals\nto have a normalized form enabling comparisons of ranges.\n\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"any","comment":" Set of all possible versions.\n\n    any == higherThan zero\n\n","type":"Range.Range"},{"name":"between","comment":" Set of versions comprised between two given versions.\nThe lower bound is included and the higher bound excluded.\n`v1 <= v < v2`.\n\n    between v1 v2 == intersection (higherThan v1) (lowerThan v2)\n\n","type":"Version.Version -> Version.Version -> Range.Range"},{"name":"contains","comment":" Check if a range selection contains a given version.\n","type":"Version.Version -> Range.Range -> Basics.Bool"},{"name":"exact","comment":" Set containing exactly one version.\n\n    exact v == intersection (higherThan v) (lowerThan <| bumpPatch v)\n\n","type":"Version.Version -> Range.Range"},{"name":"higherThan","comment":" Set of all versions higher or equal to some version.\n","type":"Version.Version -> Range.Range"},{"name":"intersection","comment":" Compute intersection of two sets of versions.\n","type":"Range.Range -> Range.Range -> Range.Range"},{"name":"lowerThan","comment":" Set of all versions strictly lower than some version.\n","type":"Version.Version -> Range.Range"},{"name":"negate","comment":" Compute the complement set of versions.\n","type":"Range.Range -> Range.Range"},{"name":"none","comment":" Empty set of versions.\n\n    none == lowerThan zero\n\n","type":"Range.Range"},{"name":"toDebugString","comment":" Displayable representation of a range, for debug purposes\n","type":"Range.Range -> String.String"},{"name":"union","comment":" Compute union of two sets of versions.\n","type":"Range.Range -> Range.Range -> Range.Range"}],"binops":[]},{"name":"Term","comment":" A term is the fundamental unit of operation of the PubGrub algorithm.\nIt is a positive or negative expression regarding a selection of versions.\nThis module exposes types and functions to deal with terms.\n\n@docs Term, isPositive, negate, toDebugString\n\n@docs acceptVersion, acceptVersionJust\n\n\n# Set operations with terms\n\n@docs intersection, union, listIntersection\n\n\n# Relation between terms\n\n@docs Relation, satisfies, contradicts, relation\n\n","unions":[{"name":"Relation","comment":" Describe a relation between a term and another set of terms.\nHere is a description extracted from PubGrub documentation.\n\nWe say that a set of terms S \"satisfies\"\na term t if t must be true whenever every term in S is true.\nConversely, S \"contradicts\" t if t must be false\nwhenever every term in S is true.\nIf neither of these is true\nwe say that S is \"inconclusive\" for t.\nAs a shorthand, we say that\na term v satisfies or contradicts t if\n{v} satisfies or contradicts it.\n\n","args":[],"cases":[["Satisfies",[]],["Contradicts",[]],["Inconclusive",[]]]},{"name":"Term","comment":" A positive or negative expression regarding a selection of versions.\n\nFor example, \"1.0.0 <= v < 2.0.0\" is a positive expression\nthat is evaluated true if a version is selected and\ncomprised between version 1.0.0 and version 2.0.0.\nThe term \"not v < 3.0.0\" is a negative expression\nthat is evaluated true if a version is selected >= 3.0.0\nor if no version is selected at all.\n\n","args":[],"cases":[["Positive",["Range.Range"]],["Negative",["Range.Range"]]]}],"aliases":[],"values":[{"name":"acceptVersion","comment":" Evaluate a term regarding a given choice\n(or absence of choice) of a version.\n","type":"Maybe.Maybe Version.Version -> Term.Term -> Basics.Bool"},{"name":"acceptVersionJust","comment":" Evaluate a term regarding a given choice of version.\n","type":"Version.Version -> Term.Term -> Basics.Bool"},{"name":"contradicts","comment":" Check if a set of terms contradicts a given term.\n\nWe say that a set of terms S \"satisfies\"\na term t if t must be true whenever every term in S is true.\n\n","type":"Term.Term -> List.List Term.Term -> Basics.Bool"},{"name":"intersection","comment":" Compute the intersection of two terms.\nIf at least one term is positive,\nthe intersection is a positive term.\n","type":"Term.Term -> Term.Term -> Term.Term"},{"name":"isPositive","comment":" Simply check if a term is positive.\n","type":"Term.Term -> Basics.Bool"},{"name":"listIntersection","comment":" Compute the intersection of a list of terms.\nAn initial term may be provided.\nOtherwise `not ∅` will be used as initialization for the intersection.\n\nWondering if it would be better to return a Maybe Term\nand let the caller decide what should mean\nthe intersection of an empty list of terms.\n\n","type":"Maybe.Maybe Term.Term -> List.List Term.Term -> Term.Term"},{"name":"negate","comment":" Negate a term.\nEvaluation of a negated term always returns the opposite\nof the evaluation of the original one.\n","type":"Term.Term -> Term.Term"},{"name":"relation","comment":" Check if a set of terms satisfies or contradicts\na given term. Otherwise the relation is inconclusive.\n","type":"Term.Term -> List.List Term.Term -> Term.Relation"},{"name":"satisfies","comment":" Check if a set of terms satisfies a given term.\n\nWe say that a set of terms S \"contradicts\"\na term t if t must be false whenever every term in S is true.\n\n","type":"Term.Term -> List.List Term.Term -> Basics.Bool"},{"name":"toDebugString","comment":" String representation of a term, for debug purposes.\n","type":"Term.Term -> String.String"},{"name":"union","comment":" Compute the union of two terms.\nIf at least one term is positive,\nthe union is a positive term.\n","type":"Term.Term -> Term.Term -> Term.Term"}],"binops":[]},{"name":"Version","comment":" Versions following the semantic versioning scheme of\nMajor.Minor.Patch.\nThis module provides functions to create and compare versions.\n\n@docs Version, toDebugString, toTuple\n\n\n# Predefined versions\n\n@docs zero, one, two, three\n\n\n# Create a new version\n\n@docs new, new_, fromTuple\n\n\n# Bump versions\n\n@docs bumpPatch, bumpMinor, bumpMajor\n\n\n# Compare versions\n\n@docs max, min, higherThan, lowerThan\n\n","unions":[{"name":"Version","comment":" Type for semantic versions.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"bumpMajor","comment":" Bump major number of a version.\n\n    bumpMajor (new_ 1 0 3) == new_ 2 0 0\n\n","type":"Version.Version -> Version.Version"},{"name":"bumpMinor","comment":" Bump minor number of a version.\n\n    bumpMinor (new_ 1 0 3) == new_ 1 1 0\n\n","type":"Version.Version -> Version.Version"},{"name":"bumpPatch","comment":" Bump patch number of a version.\n\n    bumpPatch (new_ 1 0 3) == new_ 1 0 4\n\n","type":"Version.Version -> Version.Version"},{"name":"fromTuple","comment":" Alternative constructor from a tuple.\n\n    fromTuple ( mj, mn, p ) == new_ mj mn p\n\n","type":"( Basics.Int, Basics.Int, Basics.Int ) -> Version.Version"},{"name":"higherThan","comment":" Check if a version is strictly higher than another version.\n","type":"Version.Version -> Version.Version -> Basics.Bool"},{"name":"lowerThan","comment":" Check if a version is strictly lower than another version.\n","type":"Version.Version -> Version.Version -> Basics.Bool"},{"name":"max","comment":" Return the highest of two versions.\n","type":"Version.Version -> Version.Version -> Version.Version"},{"name":"min","comment":" Return the lowest of two versions.\n","type":"Version.Version -> Version.Version -> Version.Version"},{"name":"new","comment":" Create a version with the given major, minor,\nand patch values `v = major.minor.patch`.\nNegative values are set to 0.\n","type":"{ major : Basics.Int, minor : Basics.Int, patch : Basics.Int } -> Version.Version"},{"name":"new_","comment":" Alternative constructor.\n\n    new_ mj mn p == new { major = mj, minor = mn, patch = p }\n\n","type":"Basics.Int -> Basics.Int -> Basics.Int -> Version.Version"},{"name":"one","comment":" Version 1.0.0\n","type":"Version.Version"},{"name":"three","comment":" Version 3.0.0\n","type":"Version.Version"},{"name":"toDebugString","comment":" Displayable String representation of versions, for debug purposes.\n","type":"Version.Version -> String.String"},{"name":"toTuple","comment":" Retrieve a version as a tuple.\n","type":"Version.Version -> ( Basics.Int, Basics.Int, Basics.Int )"},{"name":"two","comment":" Version 2.0.0\n","type":"Version.Version"},{"name":"zero","comment":" Version 0.0.0\n","type":"Version.Version"}],"binops":[]}]